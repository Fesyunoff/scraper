//+build !swipe

// Code generated by Swipe v2.0.0-beta6. DO NOT EDIT.

package transport

import (
	"context"
	http2 "net/http"

	"github.com/fesyunoff/availability/pkg/api/service"
	"github.com/go-kit/kit/transport/http"
	"github.com/gorilla/mux"
	"github.com/pquerna/ffjson/ffjson"
)

type errorWrapper struct {
	Error string      `json:"error"`
	Data  interface{} `json:"data,omitempty"`
}

func defaultErrorEncoder(ctx context.Context, err error, w http2.ResponseWriter) {
	var errData interface{}
	if e, ok := err.(interface{ ErrorData() interface{} }); ok {
		errData = e.ErrorData()
	}
	data, merr := ffjson.Marshal(errorWrapper{Error: err.Error(), Data: errData})
	if merr != nil {
		_, _ = w.Write([]byte("unexpected error"))
		return
	}
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	if headerer, ok := err.(http.Headerer); ok {
		for k, values := range headerer.Headers() {
			for _, v := range values {
				w.Header().Add(k, v)
			}
		}
	}
	code := http2.StatusInternalServerError
	if sc, ok := err.(http.StatusCoder); ok {
		code = sc.StatusCode()
	}
	w.WriteHeader(code)
	_, _ = w.Write(data)
}

func encodeResponseHTTP(ctx context.Context, w http2.ResponseWriter, response interface{}) (err error) {
	contentType := "application/json; charset=utf-8"
	statusCode := 200
	h := w.Header()
	var data []byte
	if response != nil {
		data, err = ffjson.Marshal(response)
		if err != nil {
			return err
		}
	} else {
		contentType = "text/plain; charset=utf-8"
		statusCode = 201
	}
	h.Set("Content-Type", contentType)
	w.WriteHeader(statusCode)
	w.Write(data)
	return nil
}

// MakeHandlerREST HTTP REST Transport
func MakeHandlerREST(svcScraperRequest service.ScraperRequest, options ...ServerOption) (http2.Handler, error) {
	opts := &serverOpts{}
	for _, o := range options {
		o(opts)
	}
	opts.genericServerOption = append(opts.genericServerOption, http.ServerErrorEncoder(defaultErrorEncoder))
	epSet := MakeScraperRequestEndpointSet(svcScraperRequest)
	epSet.GetAvailabilityEndpoint = middlewareChain(append(opts.genericEndpointMiddleware, opts.scraperRequestGetAvailabilityEndpointMiddleware...))(epSet.GetAvailabilityEndpoint)
	epSet.GetResponceTimeEndpoint = middlewareChain(append(opts.genericEndpointMiddleware, opts.scraperRequestGetResponceTimeEndpointMiddleware...))(epSet.GetResponceTimeEndpoint)
	r := mux.NewRouter()
	r.Methods(http2.MethodGet).Path("/getAvailability").Handler(http.NewServer(
		epSet.GetAvailabilityEndpoint,
		func(ctx context.Context, r *http2.Request) (interface{}, error) {
			var req GetAvailabilityRequest
			q := r.URL.Query()
			req.Site = q.Get("site")
			return req, nil
		},
		encodeResponseHTTP,
		append(opts.genericServerOption, opts.scraperRequestGetAvailabilityServerOption...)...,
	))
	r.Methods(http2.MethodGet).Path("/getResponceTime").Handler(http.NewServer(
		epSet.GetResponceTimeEndpoint,
		func(ctx context.Context, r *http2.Request) (interface{}, error) {
			var req GetResponceTimeRequest
			q := r.URL.Query()
			req.Limit = q.Get("limit")
			return req, nil
		},
		encodeResponseHTTP,
		append(opts.genericServerOption, opts.scraperRequestGetResponceTimeServerOption...)...,
	))
	return r, nil
}
